<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>使用依赖项指南 &mdash; CMake 3.29.1-g21d0c57 Documentation</title>

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a2c47e09" />
    <link rel="stylesheet" type="text/css" href="../../_static/cmake.css?v=3e562cf9" />
    
    <script src="../../_static/documentation_options.js?v=17f7ec5f"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    
    <link rel="icon" href="../../_static/cmake-favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="导入导出指南" href="../importing-exporting/index.html" />
    <link rel="prev" title="用户交互指南" href="../user-interaction/index.html" />
 

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../importing-exporting/index.html" title="导入导出指南"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../user-interaction/index.html" title="用户交互指南"
             accesskey="P">上一页</a> |</li>
  <li>
    <img src="../../_static/cmake-logo-16.png" alt=""
         style="vertical-align: middle; margin-top: -2px" />
  </li>
  <li>
    <a href="https://cmake.org/">CMake</a> &#187;
  </li>
  <li>
    <a href="../../index.html">3.29.1-g21d0c57 Documentation</a> &#187;
  </li>

        <li class="nav-item nav-item-this"><a href="">使用依赖项指南</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="guide:使用依赖项指南">
<span id="id1"></span><h1><a class="toc-backref" href="#id9" role="doc-backlink">使用依赖项指南</a><a class="headerlink" href="#guide:使用依赖项指南" title="Link to this heading">¶</a></h1>
<nav class="contents" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#guide:使用依赖项指南" id="id9">使用依赖项指南</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id10">引言</a></p></li>
<li><p><a class="reference internal" href="#find-package" id="id11">利用<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>来使用预构建包</a></p>
<ul>
<li><p><a class="reference internal" href="#libraries-providing-config-file-packages" id="id12">配置文件包</a></p></li>
<li><p><a class="reference internal" href="#find" id="id13">Find模块文件</a></p></li>
<li><p><a class="reference internal" href="#imported-targets-from-packages" id="id14">导入目标</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fetchcontent" id="id15">使用<code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>从源代码下载和构建</a></p></li>
<li><p><a class="reference internal" href="#fetchcontentfind-package" id="id16"><code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>和<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>集成</a></p></li>
<li><p><a class="reference internal" href="#dependency-providers-overview" id="id17">依赖提供器</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="id3">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">引言</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p>项目将经常依赖于其他项目、资产和工件。CMake提供了许多方法来将这些内容合并到构建中。项目和用户可以灵活地选择最适合他们需求的方法。</p>
<p>将依赖项引入构建的主要方法是<span class="target" id="index-0-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令和<span class="target" id="index-0-module:FetchContent"></span><a class="reference internal" href="../../module/FetchContent.html#module:FetchContent" title="FetchContent"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FetchContent</span></code></a>模块。有时也会使用<span class="target" id="index-0-module:FindPkgConfig"></span><a class="reference internal" href="../../module/FindPkgConfig.html#module:FindPkgConfig" title="FindPkgConfig"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FindPkgConfig</span></code></a>模块，尽管它缺少其他两个模块的一些集成，在本指南中不会进一步讨论。</p>
<p>依赖项也可以由自定义<a class="reference internal" href="../../command/cmake_language.html#dependency-providers"><span class="std std-ref">依赖提供器</span></a>提供。这可能是第三方的包管理器，也可能是由开发人员实现的定制代码。依赖提供器与上面提到的主要方法合作以扩展它们的灵活性。</p>
</section>
<section id="find-package">
<span id="prebuilt-find-package"></span><h2><a class="toc-backref" href="#id11" role="doc-backlink">利用<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>来使用预构建包</a><a class="headerlink" href="#find-package" title="Link to this heading">¶</a></h2>
<p>项目所需的包可能已经构建好，并且在用户系统的某些位置可用。这个包可能也是由CMake构建的，也可能使用完全不同的构建系统。它甚至可能只是一个根本不需要构建的文件集合。CMake为这些场景提供了<span class="target" id="index-1-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令。它搜索知名的位置，以及项目或用户提供的其他提示和路径。它还支持可选包组件和包。结果变量允许项目根据是否找到包或特定组件来定制其自己的行为。</p>
<p>在大多数情况下，项目通常应该使用<a class="reference internal" href="../../command/find_package.html#basic-signature"><span class="std std-ref">Basic Signature</span></a>。大多数时候，这将只涉及包名，可能是版本约束，如果依赖不是可选的，则需要<code class="docutils literal notranslate"><span class="pre">REQUIRED</span></code>关键字。还可以指定一组包组件。</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Examples of <code class="docutils literal notranslate"><span class="pre">find_package()</span></code> basic signature</span><a class="headerlink" href="#id7" title="Link to this code">¶</a></div>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">find_package(</span><span class="nb">Catch2</span><span class="nf">)</span>
<span class="nf">find_package(</span><span class="nb">GTest</span><span class="w"> </span><span class="no">REQUIRED</span><span class="nf">)</span>
<span class="nf">find_package(</span><span class="nb">Boost</span><span class="w"> </span><span class="m">1.79</span><span class="w"> </span><span class="no">COMPONENTS</span><span class="w"> </span><span class="nb">date_time</span><span class="nf">)</span>
</pre></div>
</div>
</div>
<p><span class="target" id="index-2-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令支持两种主要的搜索方法：</p>
<dl class="simple">
<dt><strong>配置模式</strong></dt><dd><p>使用此方法，该命令将查找包本身通常提供的文件。这是两种方法中更可靠的一种，因为包的详细信息应该始终与包保持同步。</p>
</dd>
<dt><strong>模块模式</strong></dt><dd><p>不是所有的包都是CMake感知的。许多不提供支持配置模式所需的文件。对于这种情况，Find模块文件可以由项目或CMake单独提供。Find模块通常是一种启发式实现，它知道包通常提供什么以及如何将包呈现给项目。因为Find模块通常是独立于包分发的，所以它们不那么可靠。它们通常是分开维护的，它们可能遵循不同的发布计划，所以它们很容易过时。</p>
</dd>
</dl>
<p>根据所使用的参数，<span class="target" id="index-3-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>可以使用上述方法中的一个或两个。通过将选项限制为基本签名，配置模式和模块模式都可以用来满足依赖关系。其他选项的存在可能会限制调用只能使用这两种方法中的一种，这可能会降低命令查找依赖项的能力。有关这个复杂主题的详细信息，请参阅<span class="target" id="index-4-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>文档。</p>
<p>对于这两种搜索方法，用户还可以在<span class="target" id="index-0-manual:cmake(1)"></span><a class="reference internal" href="../../manual/cmake.1.html#manual:cmake(1)" title="cmake(1)"><code class="xref cmake cmake-manual docutils literal notranslate"><span class="pre">cmake(1)</span></code></a>命令行或<span class="target" id="index-0-manual:ccmake(1)"></span><a class="reference internal" href="../../manual/ccmake.1.html#manual:ccmake(1)" title="ccmake(1)"><code class="xref cmake cmake-manual docutils literal notranslate"><span class="pre">ccmake(1)</span></code></a>或<span class="target" id="index-0-manual:cmake-gui(1)"></span><a class="reference internal" href="../../manual/cmake-gui.1.html#manual:cmake-gui(1)" title="cmake-gui(1)"><code class="xref cmake cmake-manual docutils literal notranslate"><span class="pre">cmake-gui(1)</span></code></a> UI工具中设置缓存变量，以影响和覆盖查找包的位置。有关如何设置缓存变量的更多信息，请参阅<a class="reference internal" href="../user-interaction/index.html#setting-build-variables"><span class="std std-ref">用户交互指南</span></a>。</p>
<section id="libraries-providing-config-file-packages">
<span id="id4"></span><h3><a class="toc-backref" href="#id12" role="doc-backlink">配置文件包</a><a class="headerlink" href="#libraries-providing-config-file-packages" title="Link to this heading">¶</a></h3>
<p>第三方提供与CMake一起使用的可执行文件、库、头文件和其他文件的首选方式是提供<a class="reference internal" href="../../manual/cmake-packages.7.html#config-file-packages"><span class="std std-ref">配置文件</span></a>。这些是包附带的文本文件，它们定义了CMake目标、变量、命令等。配置文件是一个普通的CMake脚本，由<span class="target" id="index-5-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令读入。</p>
<p>配置文件通常可以在名称与模式<code class="docutils literal notranslate"><span class="pre">lib/cmake/&lt;PackageName&gt;</span></code>匹配的目录中找到，尽管它们可能在其他位置（参见<a class="reference internal" href="../../command/find_package.html#search-procedure"><span class="std std-ref">Config Mode Search Procedure</span></a>）。<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;</span></code>通常是<span class="target" id="index-6-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令的第一个参数，甚至可能是唯一的参数。备选名称也可以用<code class="docutils literal notranslate"><span class="pre">NAMES</span></code>选项指定：</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">Providing alternative names when finding a package</span><a class="headerlink" href="#id8" title="Link to this code">¶</a></div>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">find_package(</span><span class="nb">SomeThing</span>
<span class="w">  </span><span class="no">NAMES</span>
<span class="w">    </span><span class="nb">SameThingOtherName</span><span class="w">   </span><span class="c"># Another name for the package</span>
<span class="w">    </span><span class="nb">SomeThing</span><span class="w">            </span><span class="c"># Also still look for its canonical name</span>
<span class="nf">)</span>
</pre></div>
</div>
</div>
<p>配置文件必须命名为<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;Config.cmake</span></code>或者<code class="docutils literal notranslate"><span class="pre">&lt;LowercasePackageName&gt;-config.cmake</span></code>（前者用于本指南的其余部分，但两者都支持）。这个文件是CMake包的入口点。一个名为<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;ConfigVersion.cmake</span></code>的单独可选文件或<code class="docutils literal notranslate"><span class="pre">&lt;LowercasePackageName&gt;-config-version.cmake</span></code>也可能存在于同一个目录中。CMake使用此文件来确定包的版本是否满足调用<span class="target" id="index-7-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>中包含的任何版本约束。调用<span class="target" id="index-8-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>时指定版本是可选的，即使是<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;ConfigVersion.cmake</span></code>文件存在。</p>
<p>如果找到<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;Config.cmake</span></code>配置文件并且满足任何版本约束，<span class="target" id="index-9-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令会认为找到的包是完整的，并假定整个包按照设计的那样完整。</p>
<p>可能有其他文件提供CMake命令或<a class="reference internal" href="../../manual/cmake-buildsystem.7.html#imported-targets"><span class="std std-ref">导入的目标</span></a>供你使用。CMake不强制这些文件的任何命名约定。它们与使用CMake的<span class="target" id="index-0-command:include"></span><a class="reference internal" href="../../command/include.html#command:include" title="include"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">include()</span></code></a>命令创建的主<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;Config.cmake</span></code>文件相关。<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;Config.cmake</span></code>文件通常会为你包含这些，所以它们通常不需要任何额外的步骤，除了调用<span class="target" id="index-10-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>。</p>
<p>如果包的位置在<a class="reference internal" href="../../command/find_package.html#search-procedure"><span class="std std-ref">CMake知道的目录</span></a>中，那么<span class="target" id="index-11-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>调用应该会成功。CMake知道的目录是特定于平台的。例如，使用标准系统包管理器在Linux上安装的包将自动在<code class="docutils literal notranslate"><span class="pre">/usr</span></code>前缀中找到。安装在Windows的<code class="docutils literal notranslate"><span class="pre">Program</span> <span class="pre">Files</span></code>中的包也会自动找到。</p>
<p>如果包在CMake不知道的位置，例如<code class="docutils literal notranslate"><span class="pre">/opt/mylib</span></code>或<code class="docutils literal notranslate"><span class="pre">$HOME/dev/prefix</span></code>，将不会在没有帮助的情况下自动找到它们。这是一种正常的情况，CMake为用户提供了几种方法来指定在哪里找到这样的库。</p>
<p><span class="target" id="index-0-variable:CMAKE_PREFIX_PATH"></span><a class="reference internal" href="../../variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code></a>变量可以<a class="reference internal" href="../user-interaction/index.html#setting-build-variables"><span class="std std-ref">在调用CMake时设置</span></a>。它被视为搜索<a class="reference internal" href="../../manual/cmake-packages.7.html#config-file-packages"><span class="std std-ref">配置文件</span></a>的基本路径列表。安装在<code class="docutils literal notranslate"><span class="pre">/opt/somepackage</span></code>中的包通常会安装配置文件，如<code class="docutils literal notranslate"><span class="pre">/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake</span></code>。在这种情况下，应该将<code class="docutils literal notranslate"><span class="pre">/opt/somepackage</span></code>添加到<span class="target" id="index-1-variable:CMAKE_PREFIX_PATH"></span><a class="reference internal" href="../../variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code></a>中。</p>
<p>环境变量<code class="docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code>也可以用前缀填充，以搜索包。与<code class="docutils literal notranslate"><span class="pre">PATH</span></code>环境变量一样，这是一个列表，但它需要使用特定于平台的环境变量列表项分隔符（<code class="docutils literal notranslate"><span class="pre">:</span></code>在Unix和<code class="docutils literal notranslate"><span class="pre">;</span></code>在Windows上）。</p>
<p><span class="target" id="index-2-variable:CMAKE_PREFIX_PATH"></span><a class="reference internal" href="../../variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code></a>变量在需要指定多个前缀的情况下提供了方便，或者在同一个前缀下可以使用多个包。包的路径也可以通过设置匹配<code class="docutils literal notranslate"><span class="pre">&lt;PackageName&gt;_DIR</span></code>的变量来指定，例如<code class="docutils literal notranslate"><span class="pre">SomePackage_DIR</span></code>。注意，这不是一个前缀，而是一个包含配置风格包文件的目录的完整路径，例如上面的例子中的<code class="docutils literal notranslate"><span class="pre">/opt/somepackage/lib/cmake/SomePackage</span></code>。有关可能影响搜索的其他CMake变量和环境变量，请参阅<span class="target" id="index-12-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>文档。</p>
</section>
<section id="find">
<span id="libraries-not-providing-config-file-packages"></span><h3><a class="toc-backref" href="#id13" role="doc-backlink">Find模块文件</a><a class="headerlink" href="#find" title="Link to this heading">¶</a></h3>
<p>不提供配置文件的包仍然可以通过<span class="target" id="index-13-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令找到，如果已获取<code class="docutils literal notranslate"><span class="pre">FindSomePackage.cmake</span></code>文件。这些Find模块文件与配置文件不同：</p>
<ol class="arabic simple">
<li><p>查找模块文件不应该由包本身提供。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Find&lt;PackageName&gt;.cmake</span></code>文件不指示包的可用性，也不指示包的任何特定部分。</p></li>
<li><p>CMake不会搜索在<span class="target" id="index-3-variable:CMAKE_PREFIX_PATH"></span><a class="reference internal" href="../../variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code></a>变量中为Find指定的<code class="docutils literal notranslate"><span class="pre">Find&lt;PackageName&gt;.cmake</span></code>文件位置。相反，CMake会在<span class="target" id="index-0-variable:CMAKE_MODULE_PATH"></span><a class="reference internal" href="../../variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_MODULE_PATH</span></code></a>变量给出的位置中搜索这些文件。用户在运行CMake时设置<span class="target" id="index-1-variable:CMAKE_MODULE_PATH"></span><a class="reference internal" href="../../variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_MODULE_PATH</span></code></a>是很常见的，而且CMake项目通常会将<span class="target" id="index-2-variable:CMAKE_MODULE_PATH"></span><a class="reference internal" href="../../variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_MODULE_PATH</span></code></a>附加到<span class="target" id="index-3-variable:CMAKE_MODULE_PATH"></span><a class="reference internal" href="../../variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_MODULE_PATH</span></code></a>中，以允许使用本地Find模块文件。</p></li>
<li><p>CMake搭载一些<span class="target" id="index-0-manual:cmake-modules(7)"></span><a class="reference internal" href="../../manual/cmake-modules.7.html#manual:cmake-modules(7)" title="cmake-modules(7)"><code class="xref cmake cmake-manual docutils literal notranslate"><span class="pre">第三方包</span></code></a>的<code class="docutils literal notranslate"><span class="pre">Find&lt;PackageName&gt;.cmake</span></code>
文件。这些文件由CMake维护负担，它们落后于与它们相关的包的最新版本是很正常的。一般来说，新的Find模块不再添加到CMake中。项目应该鼓励上游包在可能的情况下提供配置文件。如果不成功，项目应该为包提供自己的Find模块。</p></li>
</ol>
<p>有关如何编写Find模块文件的详细讨论，请参见<a class="reference internal" href="../../manual/cmake-developer.7.html#find-modules"><span class="std std-ref">查找模块</span></a>。</p>
</section>
<section id="imported-targets-from-packages">
<span id="id5"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">导入目标</a><a class="headerlink" href="#imported-targets-from-packages" title="Link to this heading">¶</a></h3>
<p>配置文件和查找模块文件都可以定义<a class="reference internal" href="../../manual/cmake-buildsystem.7.html#imported-targets"><span class="std std-ref">导入的目标</span></a>。它们通常具有<code class="docutils literal notranslate"><span class="pre">SomePrefix::ThingName</span></code>形式的名称。在可用的情况下，项目应该更倾向于使用它们，而不是可能还提供的任何CMake变量。这样的目标通常携带使用需求，并自动将诸如头搜索路径、编译器定义等应用到链接到它们的其他目标（例如使用<span class="target" id="index-0-command:target_link_libraries"></span><a class="reference internal" href="../../command/target_link_libraries.html#command:target_link_libraries" title="target_link_libraries"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">target_link_libraries()</span></code></a>）。这比试图手动使用变量应用相同的东西更健壮，也更方便。检查包或Find模块的文档，查看它定义的导入目标（如果有的话）。</p>
<p>导入的目标还应该封装任何特定于配置的路径。这包括二进制文件（库、可执行文件）、编译器标志和任何其他依赖于配置的数量的位置。在提供这些细节方面，Find模块可能不如配置文件可靠。</p>
<p>一个完整的找到第三方包并使用其中的库的示例可能如下所示：</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">cmake_minimum_required(</span><span class="no">VERSION</span><span class="w"> </span><span class="m">3.10</span><span class="nf">)</span>
<span class="nf">project(</span><span class="nb">MyExeProject</span><span class="w"> </span><span class="no">VERSION</span><span class="w"> </span><span class="m">1.0.0</span><span class="nf">)</span>

<span class="c"># Make project-provided Find modules available</span>
<span class="nf">list(</span><span class="no">APPEND</span><span class="w"> </span><span class="no">CMAKE_MODULE_PATH</span><span class="w"> </span><span class="s">&quot;${CMAKE_CURRENT_SOURCE_DIR}/cmake&quot;</span><span class="nf">)</span>

<span class="nf">find_package(</span><span class="nb">SomePackage</span><span class="w"> </span><span class="no">REQUIRED</span><span class="nf">)</span>
<span class="nf">add_executable(</span><span class="nb">MyExe</span><span class="w"> </span><span class="nb">main.cpp</span><span class="nf">)</span>
<span class="nf">target_link_libraries(</span><span class="nb">MyExe</span><span class="w"> </span><span class="no">PRIVATE</span><span class="w"> </span><span class="nb">SomePrefix</span><span class="o">::</span><span class="nb">LibName</span><span class="nf">)</span>
</pre></div>
</div>
<p>注意，上面对<span class="target" id="index-14-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>的调用可以通过配置文件或Find模块解析。它只使用<a class="reference internal" href="../../command/find_package.html#basic-signature"><span class="std std-ref">Basic Signature</span></a>支持的基本参数。例如，<code class="docutils literal notranslate"><span class="pre">${CMAKE_CURRENT_SOURCE_DIR}/cmake</span></code>目录中的<code class="docutils literal notranslate"><span class="pre">FindSomePackage.cmake</span></code>文件将允许<span class="target" id="index-15-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>命令使用模块模式成功执行。如果不存在这样的模块文件，系统将搜索配置文件。</p>
</section>
</section>
<section id="fetchcontent">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">使用<code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>从源代码下载和构建</a><a class="headerlink" href="#fetchcontent" title="Link to this heading">¶</a></h2>
<p>在CMake中使用依赖关系不一定要预先构建。它们可以作为主项目的一部分从源代码构建。<span class="target" id="index-1-module:FetchContent"></span><a class="reference internal" href="../../module/FetchContent.html#module:FetchContent" title="FetchContent"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FetchContent</span></code></a>模块提供了下载内容（通常是源代码，但也可以是任何内容）并将其添加到主项目（如果依赖项也使用CMake）的功能。依赖项的源码将与项目的其余部分一起构建，就好像这些源码是项目自己的源码的一部分一样。</p>
<p>一般的模式是，项目应该首先声明它想要使用的所有依赖项，然后要求它们可用。下面演示了原理（更多信息请参见<a class="reference internal" href="../../module/FetchContent.html#fetch-content-examples"><span class="std std-ref">Examples</span></a>）：</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">include(</span><span class="nb">FetchContent</span><span class="nf">)</span>
<span class="nf">FetchContent_Declare(</span>
<span class="w">  </span><span class="nb">googletest</span>
<span class="w">  </span><span class="no">GIT_REPOSITORY</span><span class="w"> </span><span class="na">https://github.com/google/googletest.git</span>
<span class="w">  </span><span class="no">GIT_TAG</span><span class="w">        </span><span class="m">703</span><span class="nb">bd9caab50b139428cea1aaff9974ebee5742e</span><span class="w"> </span><span class="c"># release-1.10.0</span>
<span class="nf">)</span>
<span class="nf">FetchContent_Declare(</span>
<span class="w">  </span><span class="nb">Catch2</span>
<span class="w">  </span><span class="no">GIT_REPOSITORY</span><span class="w"> </span><span class="na">https://github.com/catchorg/Catch2.git</span>
<span class="w">  </span><span class="no">GIT_TAG</span><span class="w">        </span><span class="m">605</span><span class="nb">a34765aa5d5ecbf476b4598a862ada971b0cc</span><span class="w"> </span><span class="c"># v3.0.1</span>
<span class="nf">)</span>
<span class="nf">FetchContent_MakeAvailable(</span><span class="nb">googletest</span><span class="w"> </span><span class="nb">Catch2</span><span class="nf">)</span>
</pre></div>
</div>
<p>支持各种下载方法，包括从URL下载和提取存档（支持一系列存档格式），以及许多存储库格式，包括Git、Subversion和Mercurial。还可以使用自定义下载、更新和补丁命令来支持任意用例。</p>
<p>当使用<span class="target" id="index-2-module:FetchContent"></span><a class="reference internal" href="../../module/FetchContent.html#module:FetchContent" title="FetchContent"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FetchContent</span></code></a>将依赖项添加到项目中时，项目将链接到依赖项的目标，就像项目中的任何其他目标一样。如果依赖项提供了<code class="docutils literal notranslate"><span class="pre">SomePrefix::ThingName</span></code>形式的命名空间目标，项目应该链接到这些目标，而不是任何非命名空间目标。请参阅下一节了解为什么推荐这样做。</p>
<p>并不是所有的依赖关系都可以通过这种方式引入项目。一些依赖项定义的目标名称与项目或其他依赖项中的其他目标冲突。由<span class="target" id="index-0-command:add_executable"></span><a class="reference internal" href="../../command/add_executable.html#command:add_executable" title="add_executable"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">add_executable()</span></code></a>和<span class="target" id="index-0-command:add_library"></span><a class="reference internal" href="../../command/add_library.html#command:add_library" title="add_library"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">add_library()</span></code></a>创建的具体可执行文件和库目标是全局的，因此在整个构建过程中每个目标都必须是唯一的。如果依赖项将添加冲突的目标名称，则不能使用此方法将其直接带入构建中。</p>
</section>
<section id="fetchcontentfind-package">
<h2><a class="toc-backref" href="#id16" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>和<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>集成</a><a class="headerlink" href="#fetchcontentfind-package" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">在 3.24 版本加入.</span></p>
</div>
<p>一些依赖项支持由<span class="target" id="index-16-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>或<span class="target" id="index-3-module:FetchContent"></span><a class="reference internal" href="../../module/FetchContent.html#module:FetchContent" title="FetchContent"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FetchContent</span></code></a>添加。这样的依赖关系必须确保它们在安装和从源代码构建的场景中定义相同的名称空间目标。然后，消费项目链接到这些名称空间的目标，并且可以透明地处理这两种场景，只要项目不使用这两种方法之外的任何东西。</p>
<p>项目可以通过使用<code class="docutils literal notranslate"><span class="pre">FIND_PACKAGE_ARGS</span></code>选项的<span class="target" id="index-0-command:fetchcontent_declare"></span><a class="reference internal" href="../../module/FetchContent.html#command:fetchcontent_declare" title="fetchcontent_declare"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">FetchContent_Declare()</span></code></a>来表示它乐意接受依赖项。这允许<span class="target" id="index-0-command:fetchcontent_makeavailable"></span><a class="reference internal" href="../../module/FetchContent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">FetchContent_MakeAvailable()</span></code></a>尝试先调用<span class="target" id="index-17-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>来满足依赖关系，使用<code class="docutils literal notranslate"><span class="pre">FIND_PACKAGE_ARGS</span></code>关键字后面的参数（如果有的话）。如果没有找到依赖项，则按照前面所述从源代码构建依赖项。</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">include(</span><span class="nb">FetchContent</span><span class="nf">)</span>
<span class="nf">FetchContent_Declare(</span>
<span class="w">  </span><span class="nb">googletest</span>
<span class="w">  </span><span class="no">GIT_REPOSITORY</span><span class="w"> </span><span class="na">https://github.com/google/googletest.git</span>
<span class="w">  </span><span class="no">GIT_TAG</span><span class="w">        </span><span class="m">703</span><span class="nb">bd9caab50b139428cea1aaff9974ebee5742e</span><span class="w"> </span><span class="c"># release-1.10.0</span>
<span class="w">  </span><span class="no">FIND_PACKAGE_ARGS</span><span class="w"> </span><span class="no">NAMES</span><span class="w"> </span><span class="nb">GTest</span>
<span class="nf">)</span>
<span class="nf">FetchContent_MakeAvailable(</span><span class="nb">googletest</span><span class="nf">)</span>

<span class="nf">add_executable(</span><span class="nb">ThingUnitTest</span><span class="w"> </span><span class="nb">thing_ut.cpp</span><span class="nf">)</span>
<span class="nf">target_link_libraries(</span><span class="nb">ThingUnitTest</span><span class="w"> </span><span class="nb">GTest</span><span class="o">::</span><span class="nb">gtest_main</span><span class="nf">)</span>
</pre></div>
</div>
<p>上面的例子首先调用<span class="target" id="index-18-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package(googletest</span> <span class="pre">NAMES</span> <span class="pre">GTest)</span></code></a>。CMake提供了一个<span class="target" id="index-0-module:FindGTest"></span><a class="reference internal" href="../../module/FindGTest.html#module:FindGTest" title="FindGTest"><code class="xref cmake cmake-module docutils literal notranslate"><span class="pre">FindGTest</span></code></a>模块，所以如果它发现了一个安装在某处的GTest包，它将使其可用，并且依赖关系不会从源代码构建。如果没有找到GTest包，<em>将</em>从源代码构建它。在任何一种情况下，<code class="docutils literal notranslate"><span class="pre">GTest::gtest_main</span></code>目标都需要被定义，因此我们将单元测试可执行文件链接到该目标。</p>
<p>高级控件也可以通过<span class="target" id="index-0-variable:FETCHCONTENT_TRY_FIND_PACKAGE_MODE"></span><a class="reference internal" href="../../module/FetchContent.html#variable:FETCHCONTENT_TRY_FIND_PACKAGE_MODE" title="FETCHCONTENT_TRY_FIND_PACKAGE_MODE"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">FETCHCONTENT_TRY_FIND_PACKAGE_MODE</span></code></a>变量获得。可以将其设置为<code class="docutils literal notranslate"><span class="pre">NEVER</span></code>以禁用所有对<span class="target" id="index-19-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>的重定向。即使没有指定<code class="docutils literal notranslate"><span class="pre">FIND_PACKAGE_ARGS</span></code>，也可以将其设置为<code class="docutils literal notranslate"><span class="pre">ALWAYS</span></code>以尝试<span class="target" id="index-20-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>（这应该谨慎使用）。</p>
<p>项目还可能决定必须从源代码构建特定的依赖项。如果需要补丁或未发布的依赖项版本，或者满足某些要求从源代码构建所有依赖项的策略，则可能需要这样做。项目可以通过向<span class="target" id="index-1-command:fetchcontent_declare"></span><a class="reference internal" href="../../module/FetchContent.html#command:fetchcontent_declare" title="fetchcontent_declare"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">FetchContent_Declare()</span></code></a>添加<code class="docutils literal notranslate"><span class="pre">OVERRIDE_FIND_PACKAGE</span></code>关键字来强制执行这一点。对该依赖项的<span class="target" id="index-21-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>调用将被重定向到<span class="target" id="index-1-command:fetchcontent_makeavailable"></span><a class="reference internal" href="../../module/FetchContent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">FetchContent_MakeAvailable()</span></code></a>。</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nf">include(</span><span class="nb">FetchContent</span><span class="nf">)</span>
<span class="nf">FetchContent_Declare(</span>
<span class="w">  </span><span class="nb">Catch2</span>
<span class="w">  </span><span class="no">URL</span><span class="w"> </span><span class="na">https://intranet.mycomp.com/vendored/Catch2_2.13.4_patched.tgz</span>
<span class="w">  </span><span class="no">URL_HASH</span><span class="w"> </span><span class="no">MD5</span><span class="p">=</span><span class="nb">abc123...</span>
<span class="w">  </span><span class="no">OVERRIDE_FIND_PACKAGE</span>
<span class="nf">)</span>

<span class="c"># The following is automatically redirected to FetchContent_MakeAvailable(Catch2)</span>
<span class="nf">find_package(</span><span class="nb">Catch2</span><span class="nf">)</span>
</pre></div>
</div>
<p>有关更高级的用例，请参阅<span class="target" id="index-0-variable:CMAKE_FIND_PACKAGE_REDIRECTS_DIR"></span><a class="reference internal" href="../../variable/CMAKE_FIND_PACKAGE_REDIRECTS_DIR.html#variable:CMAKE_FIND_PACKAGE_REDIRECTS_DIR" title="CMAKE_FIND_PACKAGE_REDIRECTS_DIR"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_FIND_PACKAGE_REDIRECTS_DIR</span></code></a>变量。</p>
</section>
<section id="dependency-providers-overview">
<span id="id6"></span><h2><a class="toc-backref" href="#id17" role="doc-backlink">依赖提供器</a><a class="headerlink" href="#dependency-providers-overview" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">在 3.24 版本加入.</span></p>
</div>
<p>上一节讨论了项目可用于指定其依赖项的技术。理想情况下，项目不应该真正关心依赖项来自何处，只要它提供了它所期望的东西（通常只是一些导入的目标）。在没有任何其他细节的情况下，项目说明了它需要什么，还可能指定从哪里获得它，因此它仍然可以开箱即用。</p>
<p>另一方面，开发人员可能更感兴趣的是控制<em>如何</em>向项目提供依赖项。你可能希望使用自己构建的包的特定版本。你可能希望使用第三方包管理器。出于安全性或性能原因，你可能希望将一些请求重定向到你控制的系统上的不同URL。CMake通过<a class="reference internal" href="../../command/cmake_language.html#dependency-providers"><span class="std std-ref">依赖提供器</span></a>支持这类场景。</p>
<p>依赖提供器可以设置为拦截<span class="target" id="index-22-command:find_package"></span><a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">find_package()</span></code></a>和<span class="target" id="index-2-command:fetchcontent_makeavailable"></span><a class="reference internal" href="../../module/FetchContent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">FetchContent_MakeAvailable()</span></code></a>调用。提供器有机会满足这些请求，如果提供器不能满足这些请求，就会返回到内置实现。</p>
<p>只能设置一个依赖提供器，并且只能在CMake运行早期的一个非常特定的位置设置它。<span class="target" id="index-0-variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES"></span><a class="reference internal" href="../../variable/CMAKE_PROJECT_TOP_LEVEL_INCLUDES.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES" title="CMAKE_PROJECT_TOP_LEVEL_INCLUDES"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PROJECT_TOP_LEVEL_INCLUDES</span></code></a>变量列出了将在处理第一个<span class="target" id="index-0-command:project"></span><a class="reference internal" href="../../command/project.html#command:project" title="project"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">project()</span></code></a>调用（并且仅该调用）时读取的CMake文件。这是唯一可以设置依赖项提供器的时间。在整个项目中，最多只能使用一个单一的提供者。</p>
<p>对于某些场景，用户不需要知道依赖提供器是如何设置的细节。第三方可能会提供一个可以添加到<span class="target" id="index-1-variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES"></span><a class="reference internal" href="../../variable/CMAKE_PROJECT_TOP_LEVEL_INCLUDES.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES" title="CMAKE_PROJECT_TOP_LEVEL_INCLUDES"><code class="xref cmake cmake-variable docutils literal notranslate"><span class="pre">CMAKE_PROJECT_TOP_LEVEL_INCLUDES</span></code></a>的文件，该文件将代表用户建立依赖提供器。这是包管理器的推荐方法。开发人员可以像这样使用这样的文件:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cmake -DCMAKE_PROJECT_TOP_LEVEL_INCLUDES=/path/to/package_manager/setup.cmake ...
</pre></div>
</div>
<p>有关如何实现你自己的自定义依赖提供器的详细信息，请参阅<span class="target" id="index-0-command:cmake_language"></span><a class="reference internal" href="../../command/cmake_language.html#set-dependency-provider" title="cmake_language(set_dependency_provider)"><code class="xref cmake cmake-command docutils literal notranslate"><span class="pre">cmake_language(SET_DEPENDENCY_PROVIDER)</span></code></a>命令。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">使用依赖项指南</a><ul>
<li><a class="reference internal" href="#id3">引言</a></li>
<li><a class="reference internal" href="#find-package">利用<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>来使用预构建包</a><ul>
<li><a class="reference internal" href="#libraries-providing-config-file-packages">配置文件包</a></li>
<li><a class="reference internal" href="#find">Find模块文件</a></li>
<li><a class="reference internal" href="#imported-targets-from-packages">导入目标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fetchcontent">使用<code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>从源代码下载和构建</a></li>
<li><a class="reference internal" href="#fetchcontentfind-package"><code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>和<code class="docutils literal notranslate"><span class="pre">find_package()</span></code>集成</a></li>
<li><a class="reference internal" href="#dependency-providers-overview">依赖提供器</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="../user-interaction/index.html"
                          title="上一章">用户交互指南</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="../importing-exporting/index.html"
                          title="下一章">导入导出指南</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/guide/using-dependencies/index.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../importing-exporting/index.html" title="导入导出指南"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../user-interaction/index.html" title="用户交互指南"
             >上一页</a> |</li>
  <li>
    <img src="../../_static/cmake-logo-16.png" alt=""
         style="vertical-align: middle; margin-top: -2px" />
  </li>
  <li>
    <a href="https://cmake.org/">CMake</a> &#187;
  </li>
  <li>
    <a href="../../index.html">3.29.1-g21d0c57 Documentation</a> &#187;
  </li>

        <li class="nav-item nav-item-this"><a href="">使用依赖项指南</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2000-2024 Kitware, Inc. and Contributors.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6创建。
    </div>
  </body>
</html>